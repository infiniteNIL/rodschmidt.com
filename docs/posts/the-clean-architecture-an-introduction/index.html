<!doctype html><html lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="public"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=generator content="Hugo 0.119.0"><title>The Clean Architecture: An Introduction • Rod Schmidt</title><meta name=twitter:card content="summary"><meta name=twitter:title content="The Clean Architecture: An Introduction"><meta name=twitter:description content="In the last post, I talked about various architectures used as alternatives to MVC, in a attempt to solve MVCs problems, such as Massive View Controller.
In this post, I would like to introduce you to another architecture, which seems to me to be the best starting point for your app’s architecture: the Clean Architecture.
I think I first ran into the Clean Architecture in one of Uncle Bob’s presentations on YouTube."><meta property="og:title" content="The Clean Architecture: An Introduction"><meta property="og:description" content="In the last post, I talked about various architectures used as alternatives to MVC, in a attempt to solve MVCs problems, such as Massive View Controller.
In this post, I would like to introduce you to another architecture, which seems to me to be the best starting point for your app’s architecture: the Clean Architecture.
I think I first ran into the Clean Architecture in one of Uncle Bob’s presentations on YouTube."><meta property="og:type" content="article"><meta property="og:url" content="https://rodschmidt.com/posts/the-clean-architecture-an-introduction/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-12-09T00:33:44+00:00"><meta property="article:modified_time" content="2016-12-09T00:33:44+00:00"><link rel=stylesheet href=https://rodschmidt.com/scss/hyde-hyde.0d89d10ddd2f2e23f97e661848b7ad8092fbfcbe8d60e4d1564914cf25d188d8.css integrity="sha256-DYnRDd0vLiP5fmYYSLetgJL7/L6NYOTRVkkUzyXRiNg="><link rel=stylesheet href=https://rodschmidt.com/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58+TzH3icCkSHGoJ+ed7w=" media=print><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://rodschmidt.com/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://rodschmidt.com/favicon.png></head><body><div class=sidebar><div class=container><div class=sidebar-about><span class=site__title><a href=https://rodschmidt.com/>Rod Schmidt</a></span><div class=author-image><img src="https://www.gravatar.com/avatar/e72ca1d6149c220065acbb01cd9f5d01?s=240&d=mp" class="img--circle img--headshot element--center" alt=gravatar></div><p class=site__description>Thoughts on Software Development</p></div><div class=collapsible-menu><input type=checkbox id=menuToggle>
<label for=menuToggle>Rod Schmidt</label><div class=menu-content><div><ul class=sidebar-nav><li><a href=https://rodschmidt.com/about/><span>About</span></a></li><li><a href=https://rodschmidt.com/posts/><span>Posts</span></a></li><li><a href=https://rodschmidt.com/tags/><span>Tags</span></a></li><li><a href=https://rodschmidt.com/index.xml><span>RSS</span></a></li></ul></div><section class=social><a href=https://twitter.com/rodschmidt rel=me><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a>
<a href=https://github.com/infinitenil rel=me><i class="fab fa-github fa-lg" aria-hidden=true></i></a>
<a href=https://linkedin.com/in/rodschmidt rel=me><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a>
<a href=https://stackoverflow.com/users/117435 rel=me><i class="fab fa-stack-overflow fa-lg" aria-hidden=true></i></a></section></div></div><div class=copyright>&copy; 2024 Rod Schmidt</div></div></div><div class="content container"><article><header><h1>The Clean Architecture: An Introduction</h1><div class=post__meta><i class="fas fa-calendar-alt"></i> Dec 09, 2016<br><i class="fas fa-tags"></i>
<a class="badge badge-tag" href=https://rodschmidt.com/tags/clean-architecture>clean architecture</a>
<a class="badge badge-tag" href=https://rodschmidt.com/tags/software-development>software development</a>
<a class="badge badge-tag" href=https://rodschmidt.com/tags/testing>testing</a><br></div></header><div class=post><p>In the last <a href=https://rodschmidt.com/posts/moving-towards-the-clean-architecture-for-apple-development/>post</a>, I talked about various architectures used as alternatives to MVC, in a attempt to solve MVCs problems, such as Massive View Controller.</p><p>In this post, I would like to introduce you to another architecture, which seems to me to be the best starting point for your app’s architecture: the Clean Architecture.</p><p>I think I first ran into the Clean Architecture in one of <a href="https://www.youtube.com/watch?v=WpkDN78P884">Uncle Bob’s presentations on YouTube</a>. At first, I kind of wrote it off as a typical Java over-engineered design pattern. It wasn’t until earlier this year, probably years later after my initial discovery, that I ran into it again. I was looking for a better app architecture after an experience working for a large company with a large iOS team (with about 11 developers) and all the issues they had getting the app to work and test it. I kind of became obsessed with figuring out how to make an app easier to test. I searched the internet for app architectures and studied them. It took me awhile to get my head around the Clean Architecture, but once I did, I decided it would be my starting point for an app architecture.</p><p>Uncle Bob also has a <a href=https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>blog post</a> on the Clean Architecture.</p><h2 id=origins-and-resurgence>Origins and Resurgence</h2><p>The roots of the Clean Architecture go back to the 1993, when the book <a href=http://amzn.to/2g74J3X>Object-Oriented Software Engineering: An Use-Case Driven Approach</a> by Ivar Jacobson was published. In it, Mr. Jacobson proposed a design approach where the use case was the central concept an application design was built around. A use case is very similar to what we now call a user story. It’s basically a function the user can do with the app, such as create a new user in a payroll app, for example.</p><p>According to Uncle Bob, the industry was just starting to learn that this was a good way to design applications, when in the mid to late 90s, the web arrived and threw everything into disarray. We had to figure out how to write web applications and we stopped thinking about how we did it for desktop applications.</p><p>Eventually we started thinking about architecture again, and MVC was adapted to web applications. That is probably how most developers were introduced to MVC. Maybe more recently when they started doing iOS and mobile development. Uncle Bob says MVC is not a architecture, but a design pattern. Originally, it was designed to control one single thing on the screen like a button. Every button, text field, etc., would have its own controller, view, and model. It was then adopted as an application architecture and this is the cause of its problems.</p><p>Because of these problems, everybody is thinking about architecture again and we’re seeing an explosion of app architectures. People are looking for solutions to their problems such as testing and writing code that is easy to maintain.</p><p>The Clean Architecture is very similar to these other architectures that you may have heard of:</p><ul><li><p><strong><a href=http://www.artima.com/articles/dci_vision.html>DCI</a></strong> (Data, Context, and Interaction) created by Trygve Reekskaug and James O. Coplien. Mr Reenskaug is the original creator of MVC.</p></li><li><p><strong><a href=https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)>The Hexagonal Architecture</a></strong> created by Alistair Cockburn. Also known as <strong>Ports and Adapters</strong></p></li><li><p><strong><a href=http://jeffreypalermo.com/blog/the-onion-architecture-part-1/>The Onion Architecture</a></strong> by Jeffrey Palermo.</p></li></ul><h2 id=how-it-works>How it Works</h2><p>I like to think about the Clean Architecture as a way of creating an engine for your application, much like you would create a game engine. You have some code tucked away in some libraries that is independent of the platform it will run on, or its environment. That’s really what it’s about.</p><p>Here’s a diagram of the Clean Architecture:</p><div><img style="display:block;margin:.7rem auto;border:1px solid #000;margin-bottom:0" src=https://rodschmidt.com/images/CleanArchitecture-8b00a9d7e2543fa9ca76b81b05066629.jpg title="from 8th Light" alt="from 8th Light"><p style=text-align:center;font-size:smaller>from 8th Light</p></div><p>The engine, or core of your app, are the 3 circles (yellow, red, and green) in the middle. They contain the entities, use cases, interactors, and other objects of your engine. They know nothing of UIKit, Core Data, Realm, HTTP, the web, or any other delivery mechanism, as Uncle Bob calls them.</p><p>The outer blue circle contain the external things your app needs to talk to, such as a delivery mechanism (i.e. the UI, UIKit, A web browser, etc). It also contains other things that your app needs to talk to to relate to the outside world, such as databases, networks, or even a sensor somewhere. Examples would be Core Data, a REST API, or a bluetooth sensor. These are not part of your engine or app core, and your app core will not know anything about them. It will know about some protocols it can use to talk to them.</p><p>The Clean Architecture has the following components:</p><ul><li><p><strong>Interactors</strong> - Represent the use cases and are the central objects in the Clean Architecture. You will have an interactor for every use case and they will be named after the use case. It is responsible for executing the use case by talking to entities and gateways. All the interactors together contain your application specific business logic or rules.</p></li><li><p><strong>Entities</strong> - Represent the business objects and contain business logic that could be used in multiple applications. Unlike in frameworks, they do not inherit from NSManagedObject or ActiveRecord. They are just plain simple objects, probably just structs in Swift. They do not know about the database or your network layer.</p></li><li><p><strong>Presenters</strong> - Contain your presentation logic. It is called by an interactor (through a boundary or protocol) to present something to the delivery mechanism. It does this by creating a ViewModel and passing that to the view (or view controller). Again, the presenter knows nothing of UIKit, it simply talks to an interface.</p></li><li><p><strong>ViewModels</strong> - In the Clean Architecture, the view model simply contains simple data (strings, ints, boolean, etc.) the view needs to display. It just a simple struct that contains all the data the view needs (which was prepared or formatted by the presenter). The view is very dumb. All it does is take the data and place it where it needs to go.</p></li><li><p><strong>Boundaries</strong> - You will hear Uncle Bob talk about Boundaries. They are simply just interfaces or protocols in Swift that all communication must go through to talk to another layer (or ring) in the architecture.</p></li><li><p><strong>Gateways</strong> - A gateway is simply another kind of boundary to talk to the outside world like a database, network, service, or other device that your core might need to talk to. Uncle Bob uses the term Gateway, but you and I are probably more likely to give then specific names like DatabaseStore or NetworkAPIClient for example. Again, these would be protocol names or abstract classes.</p></li></ul><h3 id=relationships-and-data-flow>Relationships and Data Flow</h3><p>Here’s another diagram I created from some other diagrams Uncle Bob had in his talk:</p><div><img style="display:block;margin:.7rem auto;border:1px solid #000;margin-bottom:0" src=https://rodschmidt.com/images/Clean-Arch.-Data-Flow.png title="Clean Architecture data flow" alt="Clean Architecture data flow" width=768><p style=text-align:center;font-size:smaller>Clean Architecture data flow</p></div><p>Let’s say we have a create user use case. Here’s how everything works:</p><ol><li><p>The user kicks things off by tapping on a new user button. Let’s say that brings up a form that the user fills out and then they tap the done button.</p></li><li><p>The view controller action connected to the button gets called. It creates a <em>RequestModel</em>, fills it with the data from the form, and passes it to a method on the boundary (or protocol) that our CreateUser interactor implements. The <em>RequestModel</em> is simply a struct that contains all the data needed by the use case. Do not include any UIKIt types in the request model. Ideally, just Swift types. Maybe some Foundation types depending on how independent you want to be from Apple’s APIs.</p></li><li><p>The interactor takes the data in the RequestModel and calls a method on the Entity Gateway Interface (or protocol) implemented by an Entity Gateway Implementation. Probably a method called something like createUser() with parameter(s) for all the data needed to create a user.</p></li><li><p>The Entity Gateway Implementation talks to the Database API (maybe Core Data) and creates a user in the database or whatever our storage mechanism is. It then takes the result of creating that user and creates a User Entity and passes that back to the interactor. The User entity is simply a struct that contains information about the user. It does not contain any storage mechanism specific information.</p></li><li><p>The interactor takes the user entity and creates a <em>ResponseModel</em>, filling it with the data from the entity. The <em>ResponseModel</em> is very similar to a RequestModel, except it is for returning a response through the boundary. The Interactor then calls a method on the boundary (or protocol) implemented by the presenter, passing it the response model.</p></li><li><p>The presenter takes the response model and creates a ViewModel filling it with data from the response model. It then calls a method on the view controller, passing it the view model.</p></li><li><p>The view controller then uses the view model to populate the view. In this case the view controller might simply present an alert that says the user was created. It might also add the the user’s name to a list that is displaying and refresh the list.</p></li></ol><h2 id=testing>Testing</h2><p>One of the benefits and main goals of the Clean Architecture is testability. Uncle Bob advocates doing Test-Driven Development (TDD), saying that writing tests after the fact are a waste of time. The tests guide your design. If the tests are hard to write then something might be wrong with your design. The tests let your refactor very quickly and tell you when you are done.</p><p>The Clean Architecture makes things easy to test with its use of boundaries. Anywhere there is a boundary (or protocol), you can substitute another object that implements the protocol. Your delivery mechanism can just be your tests. Your Entity Gateway Implementation can just return some stubbed data. This makes it very easy to test things in isolation by replacing all of an object’s dependencies with stubs or mocks. This also makes the tests very fast.</p><p>The views are really dumb and don’t really need to be tested. You can write some tests just to make sure that they call the right boundaries methods when they should. You just replace your interactor with a spy that records when a method gets called. Your tests just verify the methods are called.</p><p>Uncle Bob says you don’t need to test the views or UI. I would tend to agree with him, but I’m not sure you can completely get away with that with management. It’s easy enough to add the tests I described above. I would leave testing of the rest of the UI to the acceptance tests. Remember, you want your unit tests to run very fast. You will be using them constantly. UI testing (by that I mean user-based end-to-end black box tests) will always be be slow.</p><h3 id=acceptance-testing>Acceptance Testing</h3><p>J.B. Rainsberger is a consultant that helps companies solve their architectural and testing issues. I highly recommend his <a href=http://blog.thecodewhisperer.com/series#integrated-tests-are-a-scam>blog</a>. In a presentation called “<a href=https://vimeo.com/80533536>Integrated Tests are Scam</a>”, he talks about how it is impossible to write integrated tests that cover everything. Your tests just get slower and slower as your app grows. There are just too many code paths. All you really need to test is the boundaries. Hence the need for a good architecture like the Clean Architecture.</p><p>Have your developers write unit tests for everything (maybe even a little view testing with everything else stubbed out). They can even write some unit tests that test the integration between the different layers (i.e. test the boundaries). Leave the end-to-end testing, or acceptance tests to your QA engineers. Their job is to determine if the software is acceptable by the customer. They just need to write acceptance tests that test each use case from a user’s viewpoint. Uncle Bob was involved in the creating of an acceptance test framework called <a href=http://fitnesse.org>Fitnesse</a>.</p><h2 id=summary>Summary</h2><p>Uncle Bob says a good architecture maximizes the number of decisions not made. The Clean Architecture does that by providing clear boundaries between different parts of your app in such a way that your app doesn’t care how things behind the boundaries are implemented. This gives you tremendous flexibility and independence. You can plugin different drivers of your app (i.e. UIs or tests) whenever you want. Same thing with the other external dependencies of your app (i.e. database, network, etc.)</p><p>This article presented a lot of information, and it will probably talk multiple readings and studying of the articles and videos I linked to to fully wrap your head around it. I believe you will find it worthwhile.</p><h2 id=next-time>Next Time</h2><p>Next time, we’ll get practical. I plan to take a classic or common Cocoa example that uses MVC and convert that to the Clean Architecture.</p></div><script async data-uid=d20275c87b src=https://relentless-teacher-3937.ck.page/d20275c87b/index.js></script><div class="navigation navigation-single"><a href=https://rodschmidt.com/posts/moving-towards-the-clean-architecture-for-apple-development/ class=navigation-prev><i aria-hidden=true class="fa fa-chevron-left"></i>
<span class=navigation-tittle>Moving Towards The Clean Architecture for Apple Development</span></a>
<a href=https://rodschmidt.com/posts/the-clean-architecture-an-example/ class=navigation-next><span class=navigation-tittle>The Clean Architecture: An Example</span>
<i aria-hidden=true class="fa fa-chevron-right"></i></a></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(location.hostname==="localhost"||location.hostname==="127.0.0.1"||location.hostname==="")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="rodschmidt",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the
<a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=http://disqus.com/ class=dsq-brlink>comments powered by
<span class=logo-disqus>Disqus</span></a></article></div><script defer src=https://use.fontawesome.com/releases/v5.11.2/js/all.js integrity=sha384-b3ua1l97aVGAPEIe48b4TC60WUQbQaGi2jqAWM90y0OZXZeyaTCWtBTKtjW2GXG1 crossorigin=anonymous></script></body></html>